# 增强版人脸识别系统
# 功能：支持单张图片识别和摄像头实时识别，带有详细日志和错误处理

# 导入必要的库
import cv2
import face_recognition
import numpy as np
import os
import logging
from datetime import datetime

# 配置日志
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

class FaceRecognizer:
    """人脸识别器类，封装所有人脸识别相关功能"""
    
    def __init__(self):
        """初始化人脸识别器"""
        # 存储已知人脸数据
        self.known_face_encodings = []
        self.known_face_names = []
        self.known_face_ids = []  # 用于存储人脸唯一标识
        self.face_id_counter = 1  # 用于生成唯一ID
        
        # 实时识别相关变量
        self.video_capture = None
        self.running = False
        
        logger.info("人脸识别器初始化完成")
    
    def load_known_faces(self, directory):
        """
        从指定目录加载已知人脸
        
        参数:
            directory: 存放人脸图片的目录
        """
        # 检查目录是否存在
        if not os.path.exists(directory):
            logger.error(f"目录不存在: {directory}")
            raise FileNotFoundError(f"目录不存在: {directory}")
        
        # 确保目录有图片文件
        image_extensions = ('.jpg', '.jpeg', '.png', '.bmp')
        image_files = [f for f in os.listdir(directory) 
                      if f.lower().endswith(image_extensions)]
        
        if not image_files:
            logger.warning(f"目录 {directory} 中未找到图片文件")
            return
        
        # 加载每张图片
        for filename in image_files:
            try:
                # 构建完整路径
                file_path = os.path.join(directory, filename)
                
                # 从文件名提取姓名
                name = os.path.splitext(filename)[0]
                
                # 加载图片并获取人脸编码
                image = face_recognition.load_image_file(file_path)
                encodings = face_recognition.face_encodings(image)
                
                if not encodings:
                    logger.warning(f"无法从 {filename} 中提取人脸特征")
                    continue
                
                # 存储人脸数据
                self.known_face_encodings.append(encodings[0])
                self.known_face_names.append(name)
                self.known_face_ids.append(self.face_id_counter)
                self.face_id_counter += 1
                
                logger.info(f"成功加载人脸: {name} (ID: {self.face_id_counter - 1})")
                
            except Exception as e:
                logger.error(f"处理 {filename} 时出错: {str(e)}")
    
    def _recognize_face(self, face_encoding):
        """
        识别人脸编码对应的身份
        
        参数:
            face_encoding: 待识别的人脸编码
            
        返回:
            tuple: (姓名, ID, 匹配度)
        """
        if not self.known_face_encodings:
            return ("未知", -1, 0.0)
        
        # 计算与已知人脸的距离
        face_distances = face_recognition.face_distance(
            self.known_face_encodings, face_encoding)
        
        # 找到最接近的匹配
        best_match_index = np.argmin(face_distances)
        confidence = 1.0 - face_distances[best_match_index]
        
        # 设置匹配阈值（可根据需求调整）
        if confidence > 0.6:  # 超过60%的匹配度认为是同一个人
            return (
                self.known_face_names[best_match_index],
                self.known_face_ids[best_match_index],
                round(confidence, 2)
            )
        else:
            return ("未知", -1, round(confidence, 2))
    
    def process_image(self, input_path, output_path=None):
        """
        处理单张图片，识别人脸并标记
        
        参数:
            input_path: 输入图片路径
            output_path: 输出图片路径，为None则不保存
            
        返回:
            处理后的图片(OpenCV格式)或None
        """
        # 检查输入文件
        if not os.path.exists(input_path):
            logger.error(f"图片文件不存在: {input_path}")
            return None
        
        try:
            # 加载图片
            image = face_recognition.load_image_file(input_path)
            logger.info(f"开始处理图片: {input_path}")
            
            # 检测人脸位置和编码
            face_locations = face_recognition.face_locations(image)
            face_encodings = face_recognition.face_encodings(image, face_locations)
            
            logger.info(f"在图片中检测到 {len(face_locations)} 个人脸")
            
            # 转换为OpenCV格式以便处理
            img_cv = cv2.cvtColor(image, cv2.COLOR_RGB2BGR)
            
            # 处理每个人脸
            for (top, right, bottom, left), face_encoding in zip(face_locations, face_encodings):
                # 识别人脸
                name, face_id, confidence = self._recognize_face(face_encoding)
                
                # 绘制人脸框
                cv2.rectangle(img_cv, (left, top), (right, bottom), (0, 255, 0), 2)
                
                # 准备显示文本
                display_text = f"{name} ({confidence*100}%)"
                if face_id != -1:
                    display_text += f" ID:{face_id}"
                
                # 绘制文本背景
                cv2.rectangle(img_cv, (left, bottom - 35), (right, bottom), 
                             (0, 255, 0), cv2.FILLED)
                
                # 绘制文本
                font = cv2.FONT_HERSHEY_DUPLEX
                cv2.putText(img_cv, display_text, (left + 6, bottom - 6), 
                           font, 0.7, (0, 0, 0), 1)
                
                logger.info(f"识别到人脸: {name}, 匹配度: {confidence*100}%")
            
            # 保存结果
            if output_path:
                cv2.imwrite(output_path, img_cv)
                logger.info(f"处理结果已保存至: {output_path}")
            
            return img_cv
            
        except Exception as e:
            logger.error(f"处理图片时出错: {str(e)}")
            return None
    
    def start_realtime_recognition(self, camera_index=0):
        """
        启动实时人脸识别
        
        参数:
            camera_index: 摄像头索引，默认0为默认摄像头
        """
        # 打开摄像头
        self.video_capture = cv2.VideoCapture(camera_index)
        
        if not self.video_capture.isOpened():
            logger.error("无法打开摄像头")
            return
        
        self.running = True
        logger.info("实时人脸识别已启动，按 'q' 退出")
        
        try:
            while self.running:
                # 读取一帧
                ret, frame = self.video_capture.read()
                
                if not ret:
                    logger.error("无法获取摄像头帧")
                    break
                
                # 缩小帧以提高处理速度
                small_frame = cv2.resize(frame, (0, 0), fx=0.5, fy=0.5)
                
                # 转换颜色空间
                rgb_small_frame = small_frame[:, :, ::-1]
                
                # 检测人脸
                face_locations = face_recognition.face_locations(rgb_small_frame)
                face_encodings = face_recognition.face_encodings(rgb_small_frame, face_locations)
                
                # 处理每个人脸
                for (top, right, bottom, left), face_encoding in zip(face_locations, face_encodings):
                    # 识别人脸
                    name, face_id, confidence = self._recognize_face(face_encoding)
                    
                    # 恢复原始尺寸（因为我们之前缩小了图像）
                    top *= 2
                    right *= 2
                    bottom *= 2
                    left *= 2
                    
                    # 绘制人脸框
                    cv2.rectangle(frame, (left, top), (right, bottom), 
                                 (0, 0, 255), 2)
                    
                    # 准备显示文本
                    display_text = f"{name} ({confidence*100}%)"
                    
                    # 绘制文本背景和文本
                    cv2.rectangle(frame, (left, bottom - 35), (right, bottom), 
                                 (0, 0, 255), cv2.FILLED)
                    font = cv2.FONT_HERSHEY_DUPLEX
                    cv2.putText(frame, display_text, (left + 6, bottom - 6), 
                               font, 0.7, (255, 255, 255), 1)
                
                # 显示帧率和提示
                current_time = datetime.now().strftime("%H:%M:%S")
                cv2.putText(frame, f"时间: {current_time}  按q退出", 
                           (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.7, (255, 0, 0), 2)
                
                # 显示结果
                cv2.imshow('实时人脸识别', frame)
                
                # 检查退出命令
                if cv2.waitKey(1) & 0xFF == ord('q'):
                    self.stop_realtime_recognition()
                    break
        
        except Exception as e:
            logger.error(f"实时识别出错: {str(e)}")
            self.stop_realtime_recognition()
    
    def stop_realtime_recognition(self):
        """停止实时人脸识别"""
        self.running = False
        if self.video_capture:
            self.video_capture.release()
        cv2.destroyAllWindows()
        logger.info("实时人脸识别已停止")


def main():
    """主函数，演示人脸识别系统的使用"""
    # 创建识别器实例
    recognizer = FaceRecognizer()
    
    # 加载已知人脸（请确保该目录存在并包含人脸图片）
    try:
        recognizer.load_known_faces("known_faces")
    except Exception as e:
        logger.error(f"加载已知人脸失败: {str(e)}")
        return
    
    # 检查是否有已知人脸
    if not recognizer.known_face_encodings:
        logger.warning("未加载任何已知人脸，只能检测人脸但无法识别身份")
    
    # 选项菜单
    while True:
        print("\n人脸识别系统")
        print("1. 处理单张图片")
        print("2. 启动实时识别")
        print("3. 退出")
        
        choice = input("请选择功能 (1-3): ")
        
        if choice == '1':
            input_path = input("请输入图片路径: ")
            output_path = input("请输入结果保存路径: ")
            result = recognizer.process_image(input_path, output_path)
            
            if result is not None:
                print("图片处理完成，正在显示结果...")
                cv2.imshow("识别结果", result)
                cv2.waitKey(0)
                cv2.destroyAllWindows()
        
        elif choice == '2':
            print("启动实时识别...")
            print("提示: 按 'q' 键退出实时识别")
            recognizer.start_realtime_recognition()
        
        elif choice == '3':
            print("感谢使用，再见！")
            break
        
        else:
            print("无效选择，请重试")


if __name__ == "__main__":
    main()
